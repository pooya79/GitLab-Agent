// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from "./client";
import { client } from "./client.gen";
import type {
    CreateBotApiV1BotsPostData,
    CreateBotApiV1BotsPostErrors,
    CreateBotApiV1BotsPostResponses,
    CreateGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensPostData,
    CreateGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensPostErrors,
    CreateGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensPostResponses,
    CreateGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksPostData,
    CreateGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksPostErrors,
    CreateGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksPostResponses,
    DeleteBotApiV1BotsBotIdDeleteData,
    DeleteBotApiV1BotsBotIdDeleteErrors,
    DeleteBotApiV1BotsBotIdDeleteResponses,
    DeleteGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksHookIdDeleteData,
    DeleteGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksHookIdDeleteErrors,
    DeleteGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksHookIdDeleteResponses,
    GetAccessTokenApiV1AuthTokenSessionIdGetData,
    GetAccessTokenApiV1AuthTokenSessionIdGetErrors,
    GetAccessTokenApiV1AuthTokenSessionIdGetResponses,
    GetAvailableAvatarsApiV1BotsAvailableAvatarsGetData,
    GetAvailableAvatarsApiV1BotsAvailableAvatarsGetResponses,
    GetBotStatusApiV1BotsBotIdStatusGetData,
    GetBotStatusApiV1BotsBotIdStatusGetErrors,
    GetBotStatusApiV1BotsBotIdStatusGetResponses,
    GetCurrentUserInfoApiV1AuthMeGetData,
    GetCurrentUserInfoApiV1AuthMeGetResponses,
    GetGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdGetData,
    GetGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdGetErrors,
    GetGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdGetResponses,
    GetGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksHookIdGetData,
    GetGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksHookIdGetErrors,
    GetGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksHookIdGetResponses,
    GetGitlabUserinfoApiV1GitlabUserinfoGetData,
    GetGitlabUserinfoApiV1GitlabUserinfoGetResponses,
    GitlabAuthApiV1AuthGitlabCallbackGetData,
    GitlabAuthApiV1AuthGitlabCallbackGetErrors,
    GitlabAuthApiV1AuthGitlabCallbackGetResponses,
    GitlabLoginApiV1AuthGitlabLoginGetData,
    GitlabLoginApiV1AuthGitlabLoginGetResponses,
    ListBotsApiV1BotsGetData,
    ListBotsApiV1BotsGetErrors,
    ListBotsApiV1BotsGetResponses,
    ListGitlabProjectAccessTokensApiV1GitlabProjectsProjectIdAccessTokensGetData,
    ListGitlabProjectAccessTokensApiV1GitlabProjectsProjectIdAccessTokensGetErrors,
    ListGitlabProjectAccessTokensApiV1GitlabProjectsProjectIdAccessTokensGetResponses,
    ListGitlabProjectsApiV1GitlabProjectsGetData,
    ListGitlabProjectsApiV1GitlabProjectsGetErrors,
    ListGitlabProjectsApiV1GitlabProjectsGetResponses,
    ListGitlabProjectWebhooksApiV1GitlabProjectsProjectIdWebhooksGetData,
    ListGitlabProjectWebhooksApiV1GitlabProjectsProjectIdWebhooksGetErrors,
    ListGitlabProjectWebhooksApiV1GitlabProjectsProjectIdWebhooksGetResponses,
    LogoutApiV1AuthLogoutPostData,
    LogoutApiV1AuthLogoutPostErrors,
    LogoutApiV1AuthLogoutPostResponses,
    RefreshTokenApiV1AuthRefreshPostData,
    RefreshTokenApiV1AuthRefreshPostErrors,
    RefreshTokenApiV1AuthRefreshPostResponses,
    RevokeBotTokenApiV1BotsBodIdRevokeDeleteData,
    RevokeBotTokenApiV1BotsBodIdRevokeDeleteErrors,
    RevokeBotTokenApiV1BotsBodIdRevokeDeleteResponses,
    RevokeGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdRevokeDeleteData,
    RevokeGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdRevokeDeleteErrors,
    RevokeGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdRevokeDeleteResponses,
    RotateBotTokenApiV1BotsBotIdRotateTokenPatchData,
    RotateBotTokenApiV1BotsBotIdRotateTokenPatchErrors,
    RotateBotTokenApiV1BotsBotIdRotateTokenPatchResponses,
    RotateGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdRotatePostData,
    RotateGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdRotatePostErrors,
    RotateGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdRotatePostResponses,
    UpdateBotApiV1BotsBotIdPatchData,
    UpdateBotApiV1BotsBotIdPatchErrors,
    UpdateBotApiV1BotsBotIdPatchResponses,
} from "./types.gen";
import {
    zCreateBotApiV1BotsPostData,
    zCreateBotApiV1BotsPostResponse,
    zCreateGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensPostData,
    zCreateGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksPostData,
    zDeleteBotApiV1BotsBotIdDeleteData,
    zDeleteBotApiV1BotsBotIdDeleteResponse,
    zDeleteGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksHookIdDeleteData,
    zGetAccessTokenApiV1AuthTokenSessionIdGetData,
    zGetAccessTokenApiV1AuthTokenSessionIdGetResponse,
    zGetAvailableAvatarsApiV1BotsAvailableAvatarsGetData,
    zGetAvailableAvatarsApiV1BotsAvailableAvatarsGetResponse,
    zGetBotStatusApiV1BotsBotIdStatusGetData,
    zGetBotStatusApiV1BotsBotIdStatusGetResponse,
    zGetCurrentUserInfoApiV1AuthMeGetData,
    zGetCurrentUserInfoApiV1AuthMeGetResponse,
    zGetGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdGetData,
    zGetGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksHookIdGetData,
    zGetGitlabUserinfoApiV1GitlabUserinfoGetData,
    zGetGitlabUserinfoApiV1GitlabUserinfoGetResponse,
    zGitlabAuthApiV1AuthGitlabCallbackGetData,
    zGitlabLoginApiV1AuthGitlabLoginGetData,
    zGitlabLoginApiV1AuthGitlabLoginGetResponse,
    zListBotsApiV1BotsGetData,
    zListBotsApiV1BotsGetResponse,
    zListGitlabProjectAccessTokensApiV1GitlabProjectsProjectIdAccessTokensGetData,
    zListGitlabProjectsApiV1GitlabProjectsGetData,
    zListGitlabProjectsApiV1GitlabProjectsGetResponse,
    zListGitlabProjectWebhooksApiV1GitlabProjectsProjectIdWebhooksGetData,
    zLogoutApiV1AuthLogoutPostData,
    zRefreshTokenApiV1AuthRefreshPostData,
    zRefreshTokenApiV1AuthRefreshPostResponse,
    zRevokeBotTokenApiV1BotsBodIdRevokeDeleteData,
    zRevokeBotTokenApiV1BotsBodIdRevokeDeleteResponse,
    zRevokeGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdRevokeDeleteData,
    zRotateBotTokenApiV1BotsBotIdRotateTokenPatchData,
    zRotateBotTokenApiV1BotsBotIdRotateTokenPatchResponse,
    zRotateGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdRotatePostData,
    zUpdateBotApiV1BotsBotIdPatchData,
    zUpdateBotApiV1BotsBotIdPatchResponse,
} from "./zod.gen";

export type Options<
    TData extends TDataShape = TDataShape,
    ThrowOnError extends boolean = boolean,
> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Refresh Token
 *
 * Refresh access and refresh tokens using a valid refresh token.
 */
export const refreshTokenApiV1AuthRefreshPost = <
    ThrowOnError extends boolean = false,
>(
    options: Options<RefreshTokenApiV1AuthRefreshPostData, ThrowOnError>,
) => {
    return (options.client ?? client).post<
        RefreshTokenApiV1AuthRefreshPostResponses,
        RefreshTokenApiV1AuthRefreshPostErrors,
        ThrowOnError
    >({
        requestValidator: async (data) => {
            return await zRefreshTokenApiV1AuthRefreshPostData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zRefreshTokenApiV1AuthRefreshPostResponse.parseAsync(
                data,
            );
        },
        url: "/api/v1/auth/refresh",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options.headers,
        },
    });
};

/**
 * Logout
 *
 * Log out the currently authenticated user.
 */
export const logoutApiV1AuthLogoutPost = <ThrowOnError extends boolean = false>(
    options: Options<LogoutApiV1AuthLogoutPostData, ThrowOnError>,
) => {
    return (options.client ?? client).post<
        LogoutApiV1AuthLogoutPostResponses,
        LogoutApiV1AuthLogoutPostErrors,
        ThrowOnError
    >({
        requestValidator: async (data) => {
            return await zLogoutApiV1AuthLogoutPostData.parseAsync(data);
        },
        url: "/api/v1/auth/logout",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options.headers,
        },
    });
};

/**
 * Get Current User Info
 *
 * Get information about the currently authenticated user.
 */
export const getCurrentUserInfoApiV1AuthMeGet = <
    ThrowOnError extends boolean = false,
>(
    options?: Options<GetCurrentUserInfoApiV1AuthMeGetData, ThrowOnError>,
) => {
    return (options?.client ?? client).get<
        GetCurrentUserInfoApiV1AuthMeGetResponses,
        unknown,
        ThrowOnError
    >({
        requestValidator: async (data) => {
            return await zGetCurrentUserInfoApiV1AuthMeGetData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetCurrentUserInfoApiV1AuthMeGetResponse.parseAsync(
                data,
            );
        },
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/api/v1/auth/me",
        ...options,
    });
};

/**
 * Gitlab Login
 *
 * Redirect to GitLab for authentication.
 */
export const gitlabLoginApiV1AuthGitlabLoginGet = <
    ThrowOnError extends boolean = false,
>(
    options?: Options<GitlabLoginApiV1AuthGitlabLoginGetData, ThrowOnError>,
) => {
    return (options?.client ?? client).get<
        GitlabLoginApiV1AuthGitlabLoginGetResponses,
        unknown,
        ThrowOnError
    >({
        requestValidator: async (data) => {
            return await zGitlabLoginApiV1AuthGitlabLoginGetData.parseAsync(
                data,
            );
        },
        responseValidator: async (data) => {
            return await zGitlabLoginApiV1AuthGitlabLoginGetResponse.parseAsync(
                data,
            );
        },
        url: "/api/v1/auth/gitlab/login",
        ...options,
    });
};

/**
 * Gitlab Auth
 *
 * Handle the callback from GitLab after user authentication.
 */
export const gitlabAuthApiV1AuthGitlabCallbackGet = <
    ThrowOnError extends boolean = false,
>(
    options: Options<GitlabAuthApiV1AuthGitlabCallbackGetData, ThrowOnError>,
) => {
    return (options.client ?? client).get<
        GitlabAuthApiV1AuthGitlabCallbackGetResponses,
        GitlabAuthApiV1AuthGitlabCallbackGetErrors,
        ThrowOnError
    >({
        requestValidator: async (data) => {
            return await zGitlabAuthApiV1AuthGitlabCallbackGetData.parseAsync(
                data,
            );
        },
        url: "/api/v1/auth/gitlab/callback",
        ...options,
    });
};

/**
 * Get Access Token
 *
 * Fetch access and refresh tokens using session ID.
 */
export const getAccessTokenApiV1AuthTokenSessionIdGet = <
    ThrowOnError extends boolean = false,
>(
    options: Options<
        GetAccessTokenApiV1AuthTokenSessionIdGetData,
        ThrowOnError
    >,
) => {
    return (options.client ?? client).get<
        GetAccessTokenApiV1AuthTokenSessionIdGetResponses,
        GetAccessTokenApiV1AuthTokenSessionIdGetErrors,
        ThrowOnError
    >({
        requestValidator: async (data) => {
            return await zGetAccessTokenApiV1AuthTokenSessionIdGetData.parseAsync(
                data,
            );
        },
        responseValidator: async (data) => {
            return await zGetAccessTokenApiV1AuthTokenSessionIdGetResponse.parseAsync(
                data,
            );
        },
        url: "/api/v1/auth/token/{session_id}",
        ...options,
    });
};

/**
 * Get Gitlab Userinfo
 *
 * Get GitLab user information for the authenticated user.
 */
export const getGitlabUserinfoApiV1GitlabUserinfoGet = <
    ThrowOnError extends boolean = false,
>(
    options?: Options<
        GetGitlabUserinfoApiV1GitlabUserinfoGetData,
        ThrowOnError
    >,
) => {
    return (options?.client ?? client).get<
        GetGitlabUserinfoApiV1GitlabUserinfoGetResponses,
        unknown,
        ThrowOnError
    >({
        requestValidator: async (data) => {
            return await zGetGitlabUserinfoApiV1GitlabUserinfoGetData.parseAsync(
                data,
            );
        },
        responseValidator: async (data) => {
            return await zGetGitlabUserinfoApiV1GitlabUserinfoGetResponse.parseAsync(
                data,
            );
        },
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/api/v1/gitlab/userinfo",
        ...options,
    });
};

/**
 * List Gitlab Projects
 *
 * list GitLab projects for the authenticated user.
 */
export const listGitlabProjectsApiV1GitlabProjectsGet = <
    ThrowOnError extends boolean = false,
>(
    options?: Options<
        ListGitlabProjectsApiV1GitlabProjectsGetData,
        ThrowOnError
    >,
) => {
    return (options?.client ?? client).get<
        ListGitlabProjectsApiV1GitlabProjectsGetResponses,
        ListGitlabProjectsApiV1GitlabProjectsGetErrors,
        ThrowOnError
    >({
        requestValidator: async (data) => {
            return await zListGitlabProjectsApiV1GitlabProjectsGetData.parseAsync(
                data,
            );
        },
        responseValidator: async (data) => {
            return await zListGitlabProjectsApiV1GitlabProjectsGetResponse.parseAsync(
                data,
            );
        },
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/api/v1/gitlab/projects",
        ...options,
    });
};

/**
 * List Gitlab Project Access Tokens
 *
 * List access tokens for a GitLab project.
 */
export const listGitlabProjectAccessTokensApiV1GitlabProjectsProjectIdAccessTokensGet =
    <ThrowOnError extends boolean = false>(
        options: Options<
            ListGitlabProjectAccessTokensApiV1GitlabProjectsProjectIdAccessTokensGetData,
            ThrowOnError
        >,
    ) => {
        return (options.client ?? client).get<
            ListGitlabProjectAccessTokensApiV1GitlabProjectsProjectIdAccessTokensGetResponses,
            ListGitlabProjectAccessTokensApiV1GitlabProjectsProjectIdAccessTokensGetErrors,
            ThrowOnError
        >({
            requestValidator: async (data) => {
                return await zListGitlabProjectAccessTokensApiV1GitlabProjectsProjectIdAccessTokensGetData.parseAsync(
                    data,
                );
            },
            security: [
                {
                    scheme: "bearer",
                    type: "http",
                },
            ],
            url: "/api/v1/gitlab/projects/{project_id}/access-tokens",
            ...options,
        });
    };

/**
 * Create Gitlab Project Access Token
 *
 * Create a new access token for a GitLab project.
 */
export const createGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensPost =
    <ThrowOnError extends boolean = false>(
        options: Options<
            CreateGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensPostData,
            ThrowOnError
        >,
    ) => {
        return (options.client ?? client).post<
            CreateGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensPostResponses,
            CreateGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensPostErrors,
            ThrowOnError
        >({
            requestValidator: async (data) => {
                return await zCreateGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensPostData.parseAsync(
                    data,
                );
            },
            security: [
                {
                    scheme: "bearer",
                    type: "http",
                },
            ],
            url: "/api/v1/gitlab/projects/{project_id}/access-tokens",
            ...options,
        });
    };

/**
 * Get Gitlab Project Access Token
 *
 * Get a specific access token for a GitLab project.
 */
export const getGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdGet =
    <ThrowOnError extends boolean = false>(
        options: Options<
            GetGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdGetData,
            ThrowOnError
        >,
    ) => {
        return (options.client ?? client).get<
            GetGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdGetResponses,
            GetGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdGetErrors,
            ThrowOnError
        >({
            requestValidator: async (data) => {
                return await zGetGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdGetData.parseAsync(
                    data,
                );
            },
            security: [
                {
                    scheme: "bearer",
                    type: "http",
                },
            ],
            url: "/api/v1/gitlab/projects/{project_id}/access-tokens/{access_token_id}",
            ...options,
        });
    };

/**
 * Rotate Gitlab Project Access Token
 *
 * Rotate an existing access token for a GitLab project.
 */
export const rotateGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdRotatePost =
    <ThrowOnError extends boolean = false>(
        options: Options<
            RotateGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdRotatePostData,
            ThrowOnError
        >,
    ) => {
        return (options.client ?? client).post<
            RotateGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdRotatePostResponses,
            RotateGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdRotatePostErrors,
            ThrowOnError
        >({
            requestValidator: async (data) => {
                return await zRotateGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdRotatePostData.parseAsync(
                    data,
                );
            },
            security: [
                {
                    scheme: "bearer",
                    type: "http",
                },
            ],
            url: "/api/v1/gitlab/projects/{project_id}/access-tokens/{access_token_id}/rotate",
            ...options,
        });
    };

/**
 * Revoke Gitlab Project Access Token
 *
 * Revoke an existing access token for a GitLab project.
 */
export const revokeGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdRevokeDelete =
    <ThrowOnError extends boolean = false>(
        options: Options<
            RevokeGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdRevokeDeleteData,
            ThrowOnError
        >,
    ) => {
        return (options.client ?? client).delete<
            RevokeGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdRevokeDeleteResponses,
            RevokeGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdRevokeDeleteErrors,
            ThrowOnError
        >({
            requestValidator: async (data) => {
                return await zRevokeGitlabProjectAccessTokenApiV1GitlabProjectsProjectIdAccessTokensAccessTokenIdRevokeDeleteData.parseAsync(
                    data,
                );
            },
            security: [
                {
                    scheme: "bearer",
                    type: "http",
                },
            ],
            url: "/api/v1/gitlab/projects/{project_id}/access-tokens/{access_token_id}/revoke",
            ...options,
        });
    };

/**
 * List Gitlab Project Webhooks
 *
 * List webhooks for a GitLab project.
 */
export const listGitlabProjectWebhooksApiV1GitlabProjectsProjectIdWebhooksGet =
    <ThrowOnError extends boolean = false>(
        options: Options<
            ListGitlabProjectWebhooksApiV1GitlabProjectsProjectIdWebhooksGetData,
            ThrowOnError
        >,
    ) => {
        return (options.client ?? client).get<
            ListGitlabProjectWebhooksApiV1GitlabProjectsProjectIdWebhooksGetResponses,
            ListGitlabProjectWebhooksApiV1GitlabProjectsProjectIdWebhooksGetErrors,
            ThrowOnError
        >({
            requestValidator: async (data) => {
                return await zListGitlabProjectWebhooksApiV1GitlabProjectsProjectIdWebhooksGetData.parseAsync(
                    data,
                );
            },
            security: [
                {
                    scheme: "bearer",
                    type: "http",
                },
            ],
            url: "/api/v1/gitlab/projects/{project_id}/webhooks",
            ...options,
        });
    };

/**
 * Create Gitlab Project Webhook
 *
 * Create a new webhook for a GitLab project.
 */
export const createGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksPost =
    <ThrowOnError extends boolean = false>(
        options: Options<
            CreateGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksPostData,
            ThrowOnError
        >,
    ) => {
        return (options.client ?? client).post<
            CreateGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksPostResponses,
            CreateGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksPostErrors,
            ThrowOnError
        >({
            requestValidator: async (data) => {
                return await zCreateGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksPostData.parseAsync(
                    data,
                );
            },
            security: [
                {
                    scheme: "bearer",
                    type: "http",
                },
            ],
            url: "/api/v1/gitlab/projects/{project_id}/webhooks",
            ...options,
        });
    };

/**
 * Delete Gitlab Project Webhook
 *
 * Delete a webhook for a GitLab project.
 */
export const deleteGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksHookIdDelete =
    <ThrowOnError extends boolean = false>(
        options: Options<
            DeleteGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksHookIdDeleteData,
            ThrowOnError
        >,
    ) => {
        return (options.client ?? client).delete<
            DeleteGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksHookIdDeleteResponses,
            DeleteGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksHookIdDeleteErrors,
            ThrowOnError
        >({
            requestValidator: async (data) => {
                return await zDeleteGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksHookIdDeleteData.parseAsync(
                    data,
                );
            },
            security: [
                {
                    scheme: "bearer",
                    type: "http",
                },
            ],
            url: "/api/v1/gitlab/projects/{project_id}/webhooks/{hook_id}",
            ...options,
        });
    };

/**
 * Get Gitlab Project Webhook
 *
 * Get a specific webhook for a GitLab project.
 */
export const getGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksHookIdGet =
    <ThrowOnError extends boolean = false>(
        options: Options<
            GetGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksHookIdGetData,
            ThrowOnError
        >,
    ) => {
        return (options.client ?? client).get<
            GetGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksHookIdGetResponses,
            GetGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksHookIdGetErrors,
            ThrowOnError
        >({
            requestValidator: async (data) => {
                return await zGetGitlabProjectWebhookApiV1GitlabProjectsProjectIdWebhooksHookIdGetData.parseAsync(
                    data,
                );
            },
            security: [
                {
                    scheme: "bearer",
                    type: "http",
                },
            ],
            url: "/api/v1/gitlab/projects/{project_id}/webhooks/{hook_id}",
            ...options,
        });
    };

/**
 * Get Bot Status
 *
 * Get the status of a bot by its ID.
 */
export const getBotStatusApiV1BotsBotIdStatusGet = <
    ThrowOnError extends boolean = false,
>(
    options: Options<GetBotStatusApiV1BotsBotIdStatusGetData, ThrowOnError>,
) => {
    return (options.client ?? client).get<
        GetBotStatusApiV1BotsBotIdStatusGetResponses,
        GetBotStatusApiV1BotsBotIdStatusGetErrors,
        ThrowOnError
    >({
        requestValidator: async (data) => {
            return await zGetBotStatusApiV1BotsBotIdStatusGetData.parseAsync(
                data,
            );
        },
        responseValidator: async (data) => {
            return await zGetBotStatusApiV1BotsBotIdStatusGetResponse.parseAsync(
                data,
            );
        },
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/api/v1/bots/{bot_id}/status",
        ...options,
    });
};

/**
 * List Bots
 *
 * List all bots with pagination.
 */
export const listBotsApiV1BotsGet = <ThrowOnError extends boolean = false>(
    options?: Options<ListBotsApiV1BotsGetData, ThrowOnError>,
) => {
    return (options?.client ?? client).get<
        ListBotsApiV1BotsGetResponses,
        ListBotsApiV1BotsGetErrors,
        ThrowOnError
    >({
        requestValidator: async (data) => {
            return await zListBotsApiV1BotsGetData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zListBotsApiV1BotsGetResponse.parseAsync(data);
        },
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/api/v1/bots/",
        ...options,
    });
};

/**
 * Create Bot
 *
 * Create a new bot for a GitLab project.
 */
export const createBotApiV1BotsPost = <ThrowOnError extends boolean = false>(
    options: Options<CreateBotApiV1BotsPostData, ThrowOnError>,
) => {
    return (options.client ?? client).post<
        CreateBotApiV1BotsPostResponses,
        CreateBotApiV1BotsPostErrors,
        ThrowOnError
    >({
        requestValidator: async (data) => {
            return await zCreateBotApiV1BotsPostData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zCreateBotApiV1BotsPostResponse.parseAsync(data);
        },
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/api/v1/bots/",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options.headers,
        },
    });
};

/**
 * Delete Bot
 *
 * Delete a bot by its ID.
 */
export const deleteBotApiV1BotsBotIdDelete = <
    ThrowOnError extends boolean = false,
>(
    options: Options<DeleteBotApiV1BotsBotIdDeleteData, ThrowOnError>,
) => {
    return (options.client ?? client).delete<
        DeleteBotApiV1BotsBotIdDeleteResponses,
        DeleteBotApiV1BotsBotIdDeleteErrors,
        ThrowOnError
    >({
        requestValidator: async (data) => {
            return await zDeleteBotApiV1BotsBotIdDeleteData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zDeleteBotApiV1BotsBotIdDeleteResponse.parseAsync(
                data,
            );
        },
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/api/v1/bots/{bot_id}",
        ...options,
    });
};

/**
 * Update Bot
 *
 * Update a bot by its ID.
 */
export const updateBotApiV1BotsBotIdPatch = <
    ThrowOnError extends boolean = false,
>(
    options: Options<UpdateBotApiV1BotsBotIdPatchData, ThrowOnError>,
) => {
    return (options.client ?? client).patch<
        UpdateBotApiV1BotsBotIdPatchResponses,
        UpdateBotApiV1BotsBotIdPatchErrors,
        ThrowOnError
    >({
        requestValidator: async (data) => {
            return await zUpdateBotApiV1BotsBotIdPatchData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zUpdateBotApiV1BotsBotIdPatchResponse.parseAsync(data);
        },
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/api/v1/bots/{bot_id}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options.headers,
        },
    });
};

/**
 * Revoke Bot Token
 *
 * Revoke a bot's GitLab project access token.
 */
export const revokeBotTokenApiV1BotsBodIdRevokeDelete = <
    ThrowOnError extends boolean = false,
>(
    options: Options<
        RevokeBotTokenApiV1BotsBodIdRevokeDeleteData,
        ThrowOnError
    >,
) => {
    return (options.client ?? client).delete<
        RevokeBotTokenApiV1BotsBodIdRevokeDeleteResponses,
        RevokeBotTokenApiV1BotsBodIdRevokeDeleteErrors,
        ThrowOnError
    >({
        requestValidator: async (data) => {
            return await zRevokeBotTokenApiV1BotsBodIdRevokeDeleteData.parseAsync(
                data,
            );
        },
        responseValidator: async (data) => {
            return await zRevokeBotTokenApiV1BotsBodIdRevokeDeleteResponse.parseAsync(
                data,
            );
        },
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/api/v1/bots/{bod_id}/revoke",
        ...options,
    });
};

/**
 * Rotate Bot Token
 *
 * Rotate a bot's GitLab project access token.
 */
export const rotateBotTokenApiV1BotsBotIdRotateTokenPatch = <
    ThrowOnError extends boolean = false,
>(
    options: Options<
        RotateBotTokenApiV1BotsBotIdRotateTokenPatchData,
        ThrowOnError
    >,
) => {
    return (options.client ?? client).patch<
        RotateBotTokenApiV1BotsBotIdRotateTokenPatchResponses,
        RotateBotTokenApiV1BotsBotIdRotateTokenPatchErrors,
        ThrowOnError
    >({
        requestValidator: async (data) => {
            return await zRotateBotTokenApiV1BotsBotIdRotateTokenPatchData.parseAsync(
                data,
            );
        },
        responseValidator: async (data) => {
            return await zRotateBotTokenApiV1BotsBotIdRotateTokenPatchResponse.parseAsync(
                data,
            );
        },
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/api/v1/bots/{bot_id}/rotate-token",
        ...options,
    });
};

/**
 * Get Available Avatars
 *
 * Get a list of available bot avatars.
 */
export const getAvailableAvatarsApiV1BotsAvailableAvatarsGet = <
    ThrowOnError extends boolean = false,
>(
    options?: Options<
        GetAvailableAvatarsApiV1BotsAvailableAvatarsGetData,
        ThrowOnError
    >,
) => {
    return (options?.client ?? client).get<
        GetAvailableAvatarsApiV1BotsAvailableAvatarsGetResponses,
        unknown,
        ThrowOnError
    >({
        requestValidator: async (data) => {
            return await zGetAvailableAvatarsApiV1BotsAvailableAvatarsGetData.parseAsync(
                data,
            );
        },
        responseValidator: async (data) => {
            return await zGetAvailableAvatarsApiV1BotsAvailableAvatarsGetResponse.parseAsync(
                data,
            );
        },
        url: "/api/v1/bots/available-avatars",
        ...options,
    });
};
